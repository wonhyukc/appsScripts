/**
 * [최종 비교] 로컬 함수와 라이브러리 함수의 성능을 비교합니다. (총 4가지 방법)
 * 이 스크립트는 현재 시트의 데이터를 변경하지 않으며, 결과를 콘솔 로그에 출력합니다.
 * * @note 'hyukLib' 라이브러리가 스크립트 프로젝트에 추가되어 있어야 합니다.
 */
function runFullPerformanceComparison() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
  const columnLetter = 'A'; // 필요시 테스트할 열을 'B', 'C' 등으로 변경하세요.
  const results = {};

  console.log(`[라이브러리 포함 성능 비교] 테스트를 시작합니다. (대상 열: '${columnLetter}')`);
  console.log("현재 시트의 데이터를 그대로 사용하여 테스트를 진행합니다.");

  // --- 방법 1: 로컬 비효율 함수 (getValues) ---
  console.log("\n--- 1. 로컬 비효율 함수 (getValues) 테스트 시작 ---");
  const startTime1 = new Date().getTime();
  method1_getValues_and_Move(sheet, columnLetter);
  results.duration1 = new Date().getTime() - startTime1;
  console.log(`실행 완료. 소요 시간: ${results.duration1} ms`);
  SpreadsheetApp.flush();

  // --- 방법 2: 로컬 효율 함수 (getNextDataCell) ---
  console.log("\n--- 2. 로컬 효율 함수 (getNextDataCell) 테스트 시작 ---");
  const startTime2 = new Date().getTime();
  method2_getNextDataCell_and_Move(sheet, columnLetter);
  results.duration2 = new Date().getTime() - startTime2;
  console.log(`실행 완료. 소요 시간: ${results.duration2} ms`);
  SpreadsheetApp.flush();

  // --- 방법 3: 라이브러리 비효율 함수 (moveLastRowBad) ---
  console.log("\n--- 3. 라이브러리 비효율 함수 (hyukLib.SpreadsheetUtils.moveLastRowBad) 테스트 시작 ---");
  try {
    const startTime3 = new Date().getTime();
    hyukLib.SpreadsheetUtils.moveLastRowBad(sheet, columnLetter); // 라이브러리 함수 호출
    results.duration3 = new Date().getTime() - startTime3;
    console.log(`실행 완료. 소요 시간: ${results.duration3} ms`);
  } catch (e) {
    results.duration3 = -1; // 실패 표시
    console.error("'hyukLib.SpreadsheetUtils.moveLastRowBad' 함수 호출에 실패했습니다. 'hyukLib' 라이브러리가 올바르게 설치되었는지 확인하세요.");
    console.error(e);
  }
  SpreadsheetApp.flush();

  // --- 방법 4: 라이브러리 효율 함수 (moveLastRow) ---
  console.log("\n--- 4. 라이브러리 효율 함수 (hyukLib.SpreadsheetUtils.moveLastRow) 테스트 시작 ---");
  try {
    const startTime4 = new Date().getTime();
    hyukLib.SpreadsheetUtils.moveLastRow(sheet, columnLetter); // 라이브러리 함수 호출
    results.duration4 = new Date().getTime() - startTime4;
    console.log(`실행 완료. 소요 시간: ${results.duration4} ms`);
  } catch (e) {
    results.duration4 = -1; // 실패 표시
    console.error("'hyukLib.SpreadsheetUtils.moveLastRow' 함수 호출에 실패했습니다. 'hyukLib' 라이브러리가 올바르게 설치되었는지 확인하세요.");
    console.error(e);
  }

  // --- 최종 결과 요약 ---
  console.log("\n======================== 최종 성능 비교 결과 ========================");
  console.log(`1. 로컬 비효율 (getValues)         : ${results.duration1} ms`);
  if (results.duration3 !== -1) {
    console.log(`3. 라이브러리 비효율 (getValues)   : ${results.duration3} ms`);
  } else {
    console.log("3. 라이브러리 비효율 (getValues)   : 테스트 실패");
  }
  console.log("-----------------------------------------------------------------");
  console.log(`2. 로컬 효율 (getNextDataCell)     : ${results.duration2} ms`);
  if (results.duration4 !== -1) {
    console.log(`4. 라이브러리 효율 (getNextDataCell) : ${results.duration4} ms`);
  } else {
    console.log("4. 라이브러리 효율 (getNextDataCell) : 테스트 실패");
  }
  console.log("===================================================================");
  console.log("\n결론: getNextDataCell 방식이 월등히 빠르며, 라이브러리 호출로 인한 성능 차이는 미미하거나 없습니다.");
}


// ===============================================================
// 테스트할 로컬 메소드
// ===============================================================

/**
 * 방법 1: getValues()를 사용해 마지막 행을 찾고 커서를 이동 (비효율적)
 */
function method1_getValues_and_Move(sheet, columnLetter) {
  const colNum = getColumnNumber(columnLetter);
  if (!colNum) return 0;

  const lastRow = sheet.getLastRow();
  if (lastRow === 0) {
      sheet.setActiveRange(sheet.getRange(1, colNum));
      return 1;
  }
  const values = sheet.getRange(1, colNum, lastRow).getValues();
  
  let contentLastRow = 0;
  for (let i = values.length - 1; i >= 0; i--) {
    if (values[i][0] !== "") {
      contentLastRow = i + 1;
      break;
    }
  }
  const nextRow = contentLastRow > 0 ? contentLastRow + 1 : 1;
  sheet.setActiveRange(sheet.getRange(nextRow, colNum));
  return nextRow;
}

/**
 * 방법 2: getNextDataCell()을 사용해 마지막 행을 찾고 커서를 이동 (효율적)
 */
function method2_getNextDataCell_and_Move(sheet, columnLetter) {
  const colNum = getColumnNumber(columnLetter);
  if (!colNum) return 0;

  const startRange = sheet.getRange(sheet.getMaxRows(), colNum);
  const lastCell = startRange.getNextDataCell(SpreadsheetApp.Direction.UP);
  
  let contentLastRow = 0;
  if (lastCell.getRow() > 1 || lastCell.getValue() !== "") {
      contentLastRow = lastCell.getRow();
  }
  
  const nextRow = contentLastRow > 0 ? contentLastRow + 1 : 1;
  sheet.setActiveRange(sheet.getRange(nextRow, colNum));
  return nextRow;
}


// ===============================================================
// 보조 함수
// ===============================================================

/**
 * 열 문자를 열 번호로 변환하는 헬퍼 함수
 */
function getColumnNumber(columnLetter) {
  try {
    return columnLetter.toUpperCase().charCodeAt(0) - 64;
  } catch (e) {
    return 0;
  }
}







/**
오후 12:54:01	알림	실행이 시작됨
오후 12:54:00	정보	[라이브러리 포함 성능 비교] 테스트를 시작합니다. (대상 열: 'A')
오후 12:54:00	정보	현재 시트의 데이터를 그대로 사용하여 테스트를 진행합니다.
오후 12:54:00	정보	
--- 1. 로컬 비효율 함수 (getValues) 테스트 시작 ---
오후 12:54:04	정보	실행 완료. 소요 시간: 3613 ms
오후 12:54:04	정보	
--- 2. 로컬 효율 함수 (getNextDataCell) 테스트 시작 ---
오후 12:54:05	정보	실행 완료. 소요 시간: 191 ms
오후 12:54:05	정보	
--- 3. 라이브러리 비효율 함수 (hyukLib.SpreadsheetUtils.moveLastRowBad) 테스트 시작 ---
오후 12:54:09	정보	실행 완료. 소요 시간: 3788 ms
오후 12:54:09	정보	
--- 4. 라이브러리 효율 함수 (hyukLib.SpreadsheetUtils.moveLastRow) 테스트 시작 ---
오후 12:54:09	정보	실행 완료. 소요 시간: 255 ms
오후 12:54:09	정보	
======================== 최종 성능 비교 결과 ========================
오후 12:54:09	정보	1. 로컬 비효율 (getValues)         : 3613 ms
오후 12:54:09	정보	3. 라이브러리 비효율 (getValues)   : 3788 ms
오후 12:54:09	정보	-----------------------------------------------------------------
오후 12:54:09	정보	2. 로컬 효율 (getNextDataCell)     : 191 ms
오후 12:54:09	정보	4. 라이브러리 효율 (getNextDataCell) : 255 ms
오후 12:54:09	정보	===================================================================
오후 12:54:09	정보	
결론: getNextDataCell 방식이 월등히 빠르며, 라이브러리 호출로 인한 성능 차이는 미미하거나 없습니다.
오후 12:54:11	알림	실행이 완료됨
**/
